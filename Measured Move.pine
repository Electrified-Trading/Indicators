// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Electrified

//@version=5
indicator("Measured Move", overlay=true)
import Electrified/LocalLimit/6 as LL
import Electrified/MovingAverages/10 as MA
import Electrified/DataCleaner/5 as Data
var bar = -1
bar += 1

getATR(simple string mode, simple int period, simple float maxDeviation) =>
    trCleaned = maxDeviation==0 ? ta.tr : Data.naOutliers(ta.tr, period, maxDeviation)
    MA.get(mode, period, trCleaned)
////

var samples = input.int(100, "Minimum Samples", minval=2) + 2
var samples2x = samples * 2

padding = getATR("WMA",
  input.int(300, "Length", group="Volatility", minval=10), 4) *
  input.float(0.5, "Multiple", group="Volatility", minval=0, step=0.1)
////

getLabelX(label label) => na(label) ? na : label.get_x(label)
getLabelY(label label) => na(label) ? na : label.get_y(label)   
getLabelXY(label label) => [getLabelX(label), getLabelY(label)]    

findLabelBetween(label[] labels, int start, int end) =>
    int index = na
    label lbl = na
    last = na(start) or na(end) ? -1 : array.size(labels) - 1
    while na(index) and last >= 0
        lbl := array.get(labels, last)
        x = label.get_x(lbl)
        if x <= start
            last := -1
        else if x < end
            index := last
        last -= 1
    [index, lbl]
////

findLabelBefore(label[] labels, int end) =>
    findLabelBetween(labels, 0, end)
////

find2LabelsBetween(label[] labels, int start, int end) =>
    [latest, label1] = findLabelBetween(labels, start, end)
    x = getLabelX(label1)
    [prev, label2] = findLabelBetween(labels, start, x)
    [prev, latest]
////

deleteLower(label[] labels, int a, int b) =>
    if na(a) or na(b)
        false
    else
        aLabel = array.get(labels,a)
        bLabel = array.get(labels,b)
        aY = label.get_y(aLabel)
        bY = label.get_y(bLabel)
        if aY < bY
            array.remove(labels, a)
            label.delete(aLabel)
        else
            array.remove(labels, b)
            label.delete(bLabel)
        true
////

deleteHigher(label[] labels, int a, int b) =>
    if na(a) or na(b)
        false
    else
        aLabel = array.get(labels,a)
        bLabel = array.get(labels,b)
        aY = label.get_y(aLabel)
        bY = label.get_y(bLabel)
        if aY > bY
            array.remove(labels, a)
            label.delete(aLabel)
        else
            array.remove(labels, b)
            label.delete(bLabel)
        true
////

deleteLowerBetween(label[] labels, int start, int end) =>
    [a, b] = find2LabelsBetween(labels, start, end)
    deleteLower(labels, a, b)
////

deleteHigherBetween(label[] labels, int start, int end) =>
    [a, b] = find2LabelsBetween(labels, start, end)
    deleteHigher(labels, a, b)
////

getXValues(label[] labels) =>
    values = array.new_int()
    for e in labels
        array.push(values, label.get_x(e))
    values

var lastLo = 0
var lastHi = 0
var labelsLo = array.new_label()
var labelsHi = array.new_label()
var label lastLoLabel = na
var label lastHiLabel = na
var label activeLoLabel = label.new(0, low, color=color.gray, style=label.style_label_up)
var label activeHiLabel = label.new(0, high, color=color.gray, style=label.style_label_down)
loL1 = LL.lower(low, padding)
hiL1 = LL.upper(high, padding)
loLT = LL.trend(loL1)
loLT1 = loLT[1]
hiLT = LL.trend(hiL1)
hiLT1 = hiLT[1] 

// Add labels as data points are confirmed.
if loLT < loLT1
    i = bar - lastLo
    n = label.new(lastLo, low[i], str.tostring(lastLo), color=color.blue, style=label.style_label_up)
    array.push(labelsLo, n)
    lastLoLabel := n

    count = 0
    last = array.size(labelsLo) - 1
    while last > 0 and count < 2
        p1 = getLabelX(array.get(labelsLo, last - 1))
        p2 = getLabelX(array.get(labelsLo, last))
        deleteLowerBetween(labelsHi, p1, p2)
        last -= 1
        count += 1
////
if hiLT > hiLT1 
    i = bar - lastHi 
    n = label.new(lastHi, high[i], str.tostring(lastHi), color=color.orange, style=label.style_label_down)
    array.push(labelsHi, n)
    lastHiLabel := n

    count = 0
    last = array.size(labelsHi) - 1
    while last > 0 and count < 2
        p1 = getLabelX(array.get(labelsHi, last - 1))
        p2 = getLabelX(array.get(labelsHi, last))
        deleteHigherBetween(labelsLo, p1, p2)
        last -= 1
        count += 1
////

// Update the new lows and highs.
if loL1 < loL1[1] 
    lastLo := bar
    label.set_xy(activeLoLabel, bar, loL1)
////
if hiL1 > hiL1[1]
    lastHi := bar
    label.set_xy(activeHiLabel, bar, hiL1)
////

// Keep recent points up to date
if loL1 != loL1[1]
    deleteLowerBetween(labelsHi, getLabelX(lastLoLabel), lastLo)
////
if hiL1 != hiL1[1]
    deleteHigherBetween(labelsLo, getLabelX(lastHiLabel), lastHi)
////

// Don't retain labels that won't get used.
if array.size(labelsLo) > samples2x
    label.delete(array.shift(labelsLo))
////
if array.size(labelsHi) > samples2x
    label.delete(array.shift(labelsHi))
////

// plot(hiL1, "Limit High", color.orange, 1)
// plot(loL1, "Limit Low", color.blue, 1)

if barstate.islast

    var lines = array.new_line()
    for e in lines
        line.delete(e)
    array.clear(lines)

    // upMoves = array.new_float()
    // dnMoves = array.new_float()
    
    // Determine the vectors.
    countL = 0, countH = 0
    [activeLoX, activeLoY] = getLabelXY(activeLoLabel)
    [activeHiX, activeHiY] = getLabelXY(activeHiLabel)
    max = math.min(activeLoX, activeHiX)
    [maxLoIndex, maxLoLabel] = findLabelBefore(labelsLo, max)
    [maxHiIndex, maxHiLabel] = findLabelBefore(labelsHi, max)

    while not na(maxLoIndex) and not na(maxHiIndex) and (countL<samples or countH<samples)

        [loX, loY] = getLabelXY(maxLoLabel)
        [hiX, hiY] = getLabelXY(maxHiLabel)
        dy = hiY - loY

        if loX<hiX 
            dx = hiX - loX
            array.push(lines, line.new(activeLoX, activeLoY, activeLoX+dx, activeLoY+dy, xloc.bar_index, extend.none, color.green, line.style_dotted, 2))
            [i, a] = findLabelBefore(labelsHi, hiX)
            maxHiIndex := i, maxHiLabel := a
            countL += 1
        else
            dx = loX - hiX
            array.push(lines, line.new(activeHiX, activeHiY, activeHiX+dx, activeHiY-dy, xloc.bar_index, extend.none, color.red, line.style_dotted, 2))
            [i, a] = findLabelBefore(labelsLo, loX)
            maxLoIndex := i, maxLoLabel := a
            countH += 1
                        