// This source code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© Electrified

//@version=5
indicator("Measured Move", overlay=true)
import Electrified/LocalLimit/6 as LL
import Electrified/MovingAverages/10 as MA
import Electrified/DataCleaner/5 as Data
import Electrified/Points/6 as P
import Electrified/Time/3

barMs = Time.bar()
upLineColor = color.new(color.green, 75)
dnLineColor = color.new(color.red, 75)


var bar = -1
bar += 1
xloc = xloc.bar_time // Time allows for more accurate projection.
isXlocTime = xloc==xloc.bar_time
isXlocBar = xloc==xloc.bar_index
xlocValue = isXlocTime ? time : bar

var samples = input.int(30, "Minimum Samples", minval=2) + 2
var samples2x = samples * 2

getATR(simple string mode, simple int period, simple float maxDeviation) =>
    trCleaned = maxDeviation==0 ? ta.tr : Data.naOutliers(ta.tr, period, maxDeviation)
    MA.get(mode, period, trCleaned)
////

padding = getATR("WMA",
  input.int(2000, "Length", group="Volatility", minval=10), 4) *
  input.float(16.0, "Multiple", group="Volatility", minval=0, step=0.1)
////

getLabelX(label label) => na(label) ? na : label.get_x(label)
getLabelY(label label) => na(label) ? na : label.get_y(label)
getLabelXY(label label) => [getLabelX(label), getLabelY(label)]

lowestOffsetBar(int limit) =>
    var lows = array.new_float()
    if limit<1
        [int(na), float(na)]
    else
        array.push(lows, low)
        size = array.size(lows)
        if size > limit
            array.shift(lows)
            size -= 1

        last = size - 1
        n = 0, lo = low
        if size > 1
            for i = 0 to last - 1
                v = array.get(lows, i)
                if v<=lo
                    n := last - i
                    lo := v
        [n, lo]
////

highestOffsetBar(int limit) =>
    var highs = array.new_float()
    if limit<1
        [int(na), float(na)]
    else
        array.push(highs, high)
        size = array.size(highs)
        if size > limit
            array.shift(highs)
            size -= 1

        last = size - 1
        n = 0, hi = high
        if size > 1
            for i = 0 to last - 1
                v = array.get(highs, i)
                if v>=hi
                    n := last - i
                    hi := v
        [n, hi]
////

var lastLo = isXlocTime ? time : 0
var lastHi = isXlocTime ? time : 0
var lastLoValue = low
var lastHiValue = high
var labelsLo = array.new_label()
var labelsHi = array.new_label()
var loXValues = array.new_int()
var hiXValues = array.new_int()
var loYValues = array.new_float()
var hiYValues = array.new_float()
var label lastLoLabel = na
var label lastHiLabel = na
var label activeLoLabel = label.new(xlocValue, low, xloc=xloc, yloc=yloc.belowbar, color=color.gray, textcolor=color.white, style=label.style_triangleup, size=size.tiny)
var label activeHiLabel = label.new(xlocValue, high, xloc=xloc, yloc=yloc.abovebar, color=color.gray, textcolor=color.white, style=label.style_triangledown, size=size.tiny)
loL = LL.lower(low, padding)
hiL = LL.upper(high, padding)
loLT = LL.trend(loL), loLT1 = loLT[1]
hiLT = LL.trend(hiL), hiLT1 = hiLT[1]

enableLimitPlot = input.bool(true, "Enable upper lower limit plots")
plot(enableLimitPlot ? hiL : na, "Limit High", color.orange, 1)
plot(enableLimitPlot ? loL : na, "Limit Low", color.blue, 1)

getXYTooltip(int x, float y) =>
    str.tostring(x)+': '+str.tostring(y)
////

addLabel(label[] labels, int i, label n) =>
    size = array.size(labels)
    if i==size
        array.push(labels, n)
    else if i==0
        array.unshift(labels, n)
    else
        array.insert(labels, i, n)
    n
////

addLoPoint(int x, float y) =>
    [i, _x, _y] = P.add(loXValues, loYValues, x, y)
    addLabel(labelsLo, i, label.new(x, y, xloc=xloc, yloc=yloc.belowbar, color=color.blue, style=label.style_triangleup, size=size.tiny, tooltip=getXYTooltip(x, y)))
////

addHiPoint(int x, float y) =>
    [i, _x, _y] = P.add(hiXValues, hiYValues, x, y)
    addLabel(labelsHi, i, label.new(x, y, xloc=xloc, yloc=yloc.abovebar, color=color.orange, style=label.style_triangledown, size=size.tiny, tooltip=getXYTooltip(x, y)))
////

deleteLoPoint(int index = na) =>
    lbl = if na(index)
        P.shift(loXValues, loYValues)
        array.shift(labelsLo)
    else
        P.remove(loXValues, loYValues, index)
        array.remove(labelsLo, index)
    label.delete(lbl)
////
deleteHiPoint(int index = na) =>
    lbl = if na(index)
        P.shift(hiXValues, hiYValues)
        array.shift(labelsHi)
    else
        P.remove(hiXValues, hiYValues, index)
        array.remove(labelsHi, index)
    label.delete(lbl)
////

deleteLowerBetweenHighs(int start, int end) =>
    indexes = P.allIndexesBetween(hiXValues, start, end, ordered = true)
    size = array.size(indexes)
    if size == 0
        [int(na), float(na)]
    else
        hiIndex = array.pop(indexes)
        hiValue = array.get(hiYValues, hiIndex)
        size -= 1
        while size > 0
            nIndex = array.pop(indexes)
            nValue = array.get(hiYValues, nIndex)
            size -= 1
            if hiValue < nValue
                deleteHiPoint(hiIndex)
                hiValue := nValue
                hiIndex := nIndex
            else
                deleteHiPoint(nIndex)
                hiIndex -= 1
        [hiIndex, hiValue]
////


deleteHigherBetweenLows(int start, int end) =>
    indexes = P.allIndexesBetween(loXValues, start, end, ordered = true)
    size = array.size(indexes)
    if size == 0
        [int(na), float(na)]
    else
        loIndex = array.pop(indexes)
        loValue = array.get(loYValues, loIndex)
        size -= 1
        while size > 0
            nIndex = array.pop(indexes)
            nValue = array.get(loYValues, nIndex)
            size -= 1
            if loValue > nValue
                deleteLoPoint(loIndex)
                loValue := nValue
                loIndex := nIndex
            else
                deleteLoPoint(nIndex)
                loIndex -= 1
        [loIndex, loValue]
////


// [hbo, highest] = highestOffsetBar(lastLoOffset)
// [lbo, lowest] = lowestOffsetBar(lastHiOffset)

// Add labels as data points are confirmed.
if loLT < loLT1
    // addHiPoint(bar - hbo, highest)
    lastLoLabel := addLoPoint(lastLo, lastLoValue)

    count = 0
    last = array.size(loXValues) - 1
    while last > 0 and count < 2
        p1 = array.get(loXValues, last - 1)
        p2 = array.get(loXValues, last)
        deleteLowerBetweenHighs(p1, p2)
        last -= 1
        count += 1

////
if hiLT > hiLT1
    // addLoPoint(bar - lbo, lowest)
    lastHiLabel := addHiPoint(lastHi, lastHiValue)

    count = 0
    last = array.size(labelsHi) - 1
    while last > 0 and count < 2
        p1 = array.get(hiXValues, last - 1)
        p2 = array.get(hiXValues, last)
        deleteHigherBetweenLows(p1, p2)
        last -= 1
        count += 1
////

// Update the new lows and highs.
if loL < loL[1]
    lastLo := xlocValue
    lastLoValue := low
    label.set_xy(activeLoLabel, lastLo, loL)
    label.set_tooltip(activeLoLabel, getXYTooltip(bar, loL))
////
if hiL > hiL[1]
    lastHi := xlocValue
    lastHiValue := high
    label.set_xy(activeHiLabel, lastHi, hiL)
    label.set_tooltip(activeHiLabel, getXYTooltip(bar, hiL))
////

// Keep recent points up to date
if loL != loL[1]
    deleteLowerBetweenHighs(getLabelX(lastLoLabel), lastLo)
////
if hiL != hiL[1]
    deleteHigherBetweenLows(getLabelX(lastHiLabel), lastHi)
////

// Don't retain labels that won't get used.
if array.size(labelsLo) > samples2x
    deleteLoPoint()
////
if array.size(labelsHi) > samples2x
    deleteHiPoint()
////

if barstate.islast

    var lines = array.new_line()
    for e in lines
        line.delete(e)
    array.clear(lines)

    // Determine the vectors.
    countL = 0, countH = 0
    [activeLoX, activeLoY] = getLabelXY(activeLoLabel)
    [activeHiX, activeHiY] = getLabelXY(activeHiLabel)
    max = math.min(activeLoX, activeHiX)
    maxLoIndex = P.lastIndexBelow(loXValues, max)
    maxHiIndex = P.lastIndexBelow(hiXValues, max)

    while maxLoIndex!=-1 and maxHiIndex!=-1 and (countL<samples or countH<samples)

        [loX, loY] = P.get(loXValues, loYValues, maxLoIndex)
        [hiX, hiY] = P.get(hiXValues, hiYValues, maxHiIndex)
        dy = hiY - loY
        dx = loX < hiX ? hiX - loX : loX - hiX
        x = loX < hiX ? activeLoX : activeHiX

        if isXlocBar and dx > 500
            dy := dx * dy / 500
            dx := 500

        if loX<hiX
            // array.push(lines, line.new(loX, loY, hiX, hiY, xloc.bar_index, extend.none, upLineColor, line.style_solid, 2))
            array.push(lines, line.new(x, activeLoY, x+dx, activeLoY+dy, xloc, extend.none, upLineColor, line.style_solid, 2))
            maxHiIndex := P.lastIndexBelow(hiXValues, hiX, maxHiIndex)
            countL += 1
        else
            // array.push(lines, line.new(hiX, hiY, loX, loY, xloc.bar_index, extend.none, dnLineColor, line.style_solid, 2))
            array.push(lines, line.new(x, activeHiY, x+dx, activeHiY-dy, xloc, extend.none, dnLineColor, line.style_solid, 2))
            maxLoIndex := P.lastIndexBelow(loXValues, loX, maxLoIndex)
            countH += 1